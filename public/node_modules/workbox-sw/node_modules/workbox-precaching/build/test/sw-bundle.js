importScripts('/node_modules/mocha/mocha.js');
importScripts('/node_modules/chai/chai.js');
importScripts('/node_modules/sw-testing-helpers/build/browser/mocha-utils.js');
importScripts('/node_modules/sinon/pkg/sinon-no-sourcemaps.js');

/* globals mocha */
/* eslint-disable no-unused-vars */

self.expect = self.chai.expect;
self.chai.should();
mocha.setup({
  ui: 'bdd',
  reporter: null,
});

// This is a bit of a hack, but means workbox-runtime-caching can
// stub out fetch without triggering a mocha global leak.
// This thread inspired this "solution":
// https://github.com/sinonjs/sinon/issues/143
self.fetch = fetch;

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * A simple class to make errors and to help with testing.
 */
class ErrorFactory$1 {
  /**
   * @param {Object} errors A object containing key value pairs where the key
   * is the error name / ID and the value is the error message.
   */
  constructor(errors) {
    this._errors = errors;
  }
  /**
   * @param {string} name The error name to be generated.
   * @param {Error} [thrownError] The thrown error that resulted in this
   * message.
   * @return {Error} The generated error.
   */
  createError(name, thrownError) {
    if (!(name in this._errors)) {
      throw new Error(`Unable to generate error '${name}'.`);
    }

    let message = this._errors[name].replace(/\s+/g, ' ');
    let stack = null;
    if (thrownError) {
      message += ` [${thrownError.message}]`;
      stack = thrownError.stack;
    }

    const generatedError = new Error();
    generatedError.name = name;
    generatedError.message = message;
    generatedError.stack = stack;
    return generatedError;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

const errors = {
  'multiple-cache-will-update-plugins': 'You cannot register more than one ' +
    'plugin that implements cacheWillUpdate.',
  'multiple-cached-response-will-be-used-plugins': 'You cannot register more ' +
    'than one plugin that implements cachedResponseWillBeUsed.',
  'invalid-response-for-caching': 'The fetched response could not be cached ' +
    'due to an invalid response code.',
  'no-response-received': 'No response received; falling back to cache.',
  'bad-cache-id': `The 'cacheId' parameter must be a string with at least ` +
    `one character.`,
};

var ErrorFactory = new ErrorFactory$1(errors);

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var stackframe = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('stackframe', [], factory);
    } else {
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str[0].toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('error-stack-parser', ['stackframe'], factory);
    } else {
        module.exports = factory(stackframe);
    }
}(commonjsGlobal, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable require-jsdoc */

function atLeastOne(object) {
  const parameters = Object.keys(object);
  if (!parameters.some((parameter) => object[parameter] !== undefined)) {
    throwError('Please set at least one of the following parameters: ' +
      parameters.map((p) => `'${p}'`).join(', '));
  }
}



function isInstance(object, expectedClass) {
  const parameter = Object.keys(object).pop();
  if (!(object[parameter] instanceof expectedClass)) {
    throwError(`The '${parameter}' parameter must be an instance of
      '${expectedClass.name}'`);
  }
}



function isType(object, expectedType) {
  const parameter = Object.keys(object).pop();
  const actualType = typeof object[parameter];
  if (actualType !== expectedType) {
    throwError(`The '${parameter}' parameter has the wrong type. (Expected:
      ${expectedType}, actual: ${actualType})`);
  }
}

function isArrayOfType(object, expectedType) {
  const parameter = Object.keys(object).pop();
  const message = `The '${parameter}' parameter should be an array containing
    one or more '${expectedType}' elements.`;

  if (!Array.isArray(object[parameter])) {
    throwError(message);
  }

  for (let item of object[parameter]) {
    if (typeof item !== expectedType) {
      throwError(message);
    }
  }
}





function throwError(message) {
  // Collapse any newlines or whitespace into a single space.
  message = message.replace(/\s+/g, ' ');

  const error = new Error(message);
  error.name = 'assertion-failed';

  const stackFrames = errorStackParser.parse(error);

  // If, for some reason, we don't have all the stack information we need,
  // we'll just end up throwing a basic Error.
  if (stackFrames.length >= 3) {
    // Assuming we have the stack frames, set the message to include info
    // about what the underlying method was, and set the name to reflect
    // the assertion type that failed.
    error.message = `Invalid call to ${stackFrames[2].functionName}() — ` +
      message;
  }

  throw error;
}

/* eslint-disable no-console */

/**
 * A simple helper to manage the print of a set of logs
 */
class LogGroup {
  /**
   * @param {object} input
   */
  constructor() {
    this._logs = [];
    this._childGroups = [];

    this._isFallbackMode = false;
    const ffRegex = /Firefox\/(\d*)\.\d*/.exec(navigator.userAgent);
    if (ffRegex) {
      try {
        const ffVersion = parseInt(ffRegex[1], 10);
        if (ffVersion < 55) {
          this._isFallbackMode = true;
        }
      } catch (err) {
        this._isFallbackMode = true;
      }
    }

    if (/Edge\/\d*\.\d*/.exec(navigator.userAgent)) {
      this._isFallbackMode = true;
    }
  }

  /**
   *@param {object} logDetails
   */
  addPrimaryLog(logDetails) {
    this._primaryLog = logDetails;
  }

  /**
   *@param {object} logDetails
   */
  addLog(logDetails) {
    this._logs.push(logDetails);
  }

  /**
   * @param {object} group
   */
  addChildGroup(group) {
    if (group._logs.length === 0) {
      return;
    }

    this._childGroups.push(group);
  }

  /**
   * prints out this log group to the console.
   */
  print() {
    if (this._logs.length === 0 && this._childGroups.length === 0) {
      this._printLogDetails(this._primaryLog);
      return;
    }

    if (this._primaryLog) {
      if (!this._isFallbackMode) {
        console.groupCollapsed(...this._getLogContent(this._primaryLog));
      } else {
        this._printLogDetails(this._primaryLog);
      }
    }

    this._logs.forEach((logDetails) => {
      this._printLogDetails(logDetails);
    });

    this._childGroups.forEach((group) => {
      group.print();
    });

    if (this._primaryLog && !this._isFallbackMode) {
      console.groupEnd();
    }
  }

  /**
   * Prints the specific logDetails object.
   * @param {object} logDetails
   */
  _printLogDetails(logDetails) {
    const logFunc = logDetails.logFunc ? logDetails.logFunc : console.log;
    logFunc(...this._getLogContent(logDetails));
  }

  /**
   * Returns a flattened array of message with colors and args.
   * @param {object} logDetails
   * @return {Array} Returns an array of arguments to pass to a console
   * function.
   */
  _getLogContent(logDetails) {
    let message = logDetails.message;
    if (this._isFallbackMode && typeof message === 'string') {
      // Replace the %c value with an empty string.
      message = message.replace(/%c/g, '');
    }

    let allArguments = [message];

    if (!this._isFallbackMode && logDetails.colors) {
      allArguments = allArguments.concat(logDetails.colors);
    }

    if (logDetails.args) {
      allArguments = allArguments.concat(logDetails.args);
    }
    return allArguments;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * @private
 * @return {boolean} True, if we're running in the service worker global scope.
 * False otherwise.
 */
function isServiceWorkerGlobalScope() {
  return ('ServiceWorkerGlobalScope' in self &&
          self instanceof ServiceWorkerGlobalScope);
}

/**
 * @private
 * @return {boolean} True, if we're running a development bundle.
 * False otherwise.
 */
function isDevBuild() {
  // `BUILD_PROCESS_REPLACE::BUILD_TARGET` is replaced during the build process.
  return `BUILD_PROCESS_REPLACE::BUILD_TARGET` === `dev`;
}

/**
 * @private
 * @return {boolean} True, if we're running on localhost or the equivalent IP
 * address. False otherwise.
 */

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable no-console */

self.workbox = self.workbox || {};
self.workbox.LOG_LEVEL = self.workbox.LOG_LEVEL || {
  none: -1,
  verbose: 0,
  debug: 1,
  warn: 2,
  error: 3,
};

const LIGHT_GREY = `#bdc3c7`;
const DARK_GREY = `#7f8c8d`;
const LIGHT_GREEN = `#2ecc71`;
const LIGHT_YELLOW = `#f1c40f`;
const LIGHT_RED = `#e74c3c`;
const LIGHT_BLUE = `#3498db`;

/**
 * A class that will only log given the current log level
 * defined by the developer.
 *
 * Define custom log level by setting `self.workbox.logLevel`.
 *
 * @example
 *
 * self.workbox.logLevel = self.workbox.LOG_LEVEL.verbose;
 *
 * @private
 */
class LogHelper {
  /**
   * LogHelper constructor.
   */
  constructor() {
    this._defaultLogLevel = isDevBuild() ?
      self.workbox.LOG_LEVEL.debug :
      self.workbox.LOG_LEVEL.warn;
  }

  /**
   * The most verbose log level.
   *
   * @param {Object} options The options of the log.
   */
  log(options) {
    this._printMessage(self.workbox.LOG_LEVEL.verbose, options);
  }

  /**
   * Useful for logs that are more exceptional that log()
   * but not severe.
   *
   * @param {Object} options The options of the log.
   */
  debug(options) {
    this._printMessage(self.workbox.LOG_LEVEL.debug, options);
  }

  /**
   * Warning messages.
   *
   * @param {Object} options The options of the log.
   */
  warn(options) {
    this._printMessage(self.workbox.LOG_LEVEL.warn, options);
  }

  /**
   * Error logs.
   *
   * @param {Object} options The options of the log.
   */
  error(options) {
    this._printMessage(self.workbox.LOG_LEVEL.error, options);
  }

  /**
   * Method to print to the console.
   * @param {number} logLevel
   * @param {Object} logOptions
   */
  _printMessage(logLevel, logOptions) {
    if (!this._shouldLogMessage(logLevel, logOptions)) {
      return;
    }

    const logGroups = this._getAllLogGroups(logLevel, logOptions);
    logGroups.print();
  }

  /**
   * Print a user friendly log to the console.
   * @param  {numer} logLevel A number from self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {LogGroup} Returns a log group to print to the console.
   */
  _getAllLogGroups(logLevel, logOptions) {
    const topLogGroup = new LogGroup();

    const primaryMessage = this._getPrimaryMessageDetails(logLevel, logOptions);
    topLogGroup.addPrimaryLog(primaryMessage);

    if (logOptions.error) {
      const errorMessage = {
        message: logOptions.error,
        logFunc: console.error,
      };
      topLogGroup.addLog(errorMessage);
    }

    const extraInfoGroup = new LogGroup();
    if (logOptions.that && logOptions.that.constructor &&
      logOptions.that.constructor.name) {
      const className = logOptions.that.constructor.name;
      extraInfoGroup.addLog(
        this._getKeyValueDetails('class', className)
      );
    }

    if (logOptions.data) {
      if (typeof logOptions.data === 'object' &&
        !(logOptions.data instanceof Array)) {
        Object.keys(logOptions.data).forEach((keyName) => {
          extraInfoGroup.addLog(
            this._getKeyValueDetails(keyName, logOptions.data[keyName])
          );
        });
      } else {
        extraInfoGroup.addLog(
          this._getKeyValueDetails('additionalData', logOptions.data)
        );
      }
    }

    topLogGroup.addChildGroup(extraInfoGroup);

    return topLogGroup;
  }

  /**
   * This is a helper function to wrap key value pairss to a colored key
   * value string.
   * @param  {string} key
   * @param  {string} value
   * @return {Object} The object containing a message, color and Arguments
   * for the console.
   */
  _getKeyValueDetails(key, value) {
    return {
      message: `%c${key}: `,
      colors: [`color: ${LIGHT_BLUE}`],
      args: value,
    };
  }

  /**
   * Helper method to color the primary message for the log
   * @param  {number} logLevel   One of self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {Object} Object containing the message and color info to print.
   */
  _getPrimaryMessageDetails(logLevel, logOptions) {
    let logLevelName;
    let logLevelColor;
    switch (logLevel) {
      case self.workbox.LOG_LEVEL.verbose:
        logLevelName = 'Info';
        logLevelColor = LIGHT_GREY;
        break;
      case self.workbox.LOG_LEVEL.debug:
        logLevelName = 'Debug';
        logLevelColor = LIGHT_GREEN;
        break;
      case self.workbox.LOG_LEVEL.warn:
        logLevelName = 'Warn';
        logLevelColor = LIGHT_YELLOW;
        break;
      case self.workbox.LOG_LEVEL.error:
        logLevelName = 'Error';
        logLevelColor = LIGHT_RED;
        break;
    }

    let primaryLogMessage = `%c🔧 %c[${logLevelName}]`;
    const primaryLogColors = [
      `color: ${LIGHT_GREY}`,
      `color: ${logLevelColor}`,
    ];

    let message;
    if (typeof logOptions === 'string') {
      message = logOptions;
    } else if (logOptions.message) {
      message = logOptions.message;
    }

    if (message) {
      message = message.replace(/\s+/g, ' ');
      primaryLogMessage += `%c ${message}`;
      primaryLogColors.push(`color: ${DARK_GREY}; font-weight: normal`);
    }

    return {
      message: primaryLogMessage,
      colors: primaryLogColors,
    };
  }

  /**
   * Test if the message should actually be logged.
   * @param {number} logLevel The level of the current log to be printed.
   * @param {Object|String} logOptions The options to log.
   * @return {boolean} Returns true of the message should be printed.
   */
  _shouldLogMessage(logLevel, logOptions) {
    if (!logOptions) {
      return false;
    }

    let minValidLogLevel = this._defaultLogLevel;
    if (self && self.workbox && typeof self.workbox.logLevel === 'number') {
      minValidLogLevel = self.workbox.logLevel;
    }

    if (minValidLogLevel === self.workbox.LOG_LEVEL.none ||
      logLevel < minValidLogLevel) {
      return false;
    }

    return true;
  }
}

var logHelper = new LogHelper();

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Use this plugin to cache responses with certain HTTP status codes or
 * header values.
 *
 * Defining both status codes and headers will cache requests with a matching
 * status code and a matching header.
 *
 * @example
 * new workbox.cacheableResponse.CacheableResponse({
 *   statuses: [0, 200, 404],
 *   headers: {
 *     'Example-Header-1': 'Header-Value-1'
 *     'Example-Header-2': 'Header-Value-2'
 *   }
 * })
 *
 * @memberof module:workbox-cacheable-response
 */
class CacheableResponse {
  /**
   * Creates a new `Plugin` instance, which stores configuration and logic
   * to determine whether a `Response` object is cacheable or not.
   *
   * If multiple criteria are present (e.g. both `statuses` and `headers`), then
   * the `Response` needs to meet all of the criteria to be cacheable.
   *
   * @param {Object} input
   * @param {Array<Number>} [input.statuses] The status codes that are
   *        checked when determining whether a `Response` is cacheable.
   * @param {Object<String,String>} [input.headers] The header values that are
   *        checked when determining whether a `Response` is cacheable.
   */
  constructor({statuses, headers} = {}) {
    atLeastOne({statuses, headers});
    if (statuses !== undefined) {
      isArrayOfType({statuses}, 'number');
    }
    if (headers !== undefined) {
      isType({headers}, 'object');
    }

    this.statuses = statuses;
    this.headers = headers;
  }

  /**
   * Checks a response to see whether it's cacheable or not, based on the
   * configuration of this object.
   *
   * @param {Object} input
   * @param {Response} input.response The response that might be cached.
   * @param {Request} [input.request] Optionally, the request that led to the
   *        response.
   * @return {boolean} `true` if the `Response` is cacheable, based on the
   *          configuration of this object, and `false` otherwise.
   */
  isResponseCacheable({request, response} = {}) {
    isInstance({response}, Response);

    let cacheable = true;

    if (this.statuses) {
      cacheable = this.statuses.includes(response.status);
    }

    if (this.headers && cacheable) {
      cacheable = Object.keys(this.headers).some((headerName) => {
        return response.headers.get(headerName) === this.headers[headerName];
      });
    }

    if (!cacheable) {
      const data = {response};
      if (this.statuses) {
        data['valid-status-codes'] = JSON.stringify(this.statuses);
      }
      if (this.headers) {
        data['valid-headers'] = JSON.stringify(this.headers);
      }
      if (request) {
        data['request'] = request;
      }

      logHelper.debug({
        message: `The response does not meet the criteria for being added to the
          cache.`,
        data,
      });
    }

    return cacheable;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Use this plugin to cache responses with certain HTTP status codes or
 * header values.
 *
 * Defining both status codes and headers will cache requests with a matching
 * status code and a matching header.
 *
 * This class is meant to be automatically invoked as a plugin to a
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper}, which
 * is used by the `workbox-sw` and `workbox-runtime-caching` modules.
 *
 * If you would like to use this functionality outside of the `RequestWrapper`
 * context, please use the `CacheableResponse` class directly.
 *
 * @example
 * new workbox.cacheableResponse.CacheableResponsePlugin({
 *   statuses: [0, 200, 404],
 *   headers: {
 *     'Example-Header-1': 'Header-Value-1'
 *     'Example-Header-2': 'Header-Value-2'
 *   }
 * });
 *
 * @memberof module:workbox-cacheable-response
 */
class CacheableResponsePlugin extends CacheableResponse {
  /**
   * A "lifecycle" callback that will be triggered automatically by the
   * `workbox.runtimeCaching` handlers prior to an entry being added to a cache.
   *
   * @private
   * @param {Object} input
   * @param {Request} input.request The request that led to the response.
   * @param {Response} input.response The response that might be cached.
   * @return {boolean} `true` if the `Response` is cacheable, based on the
   *          configuration of this object, and `false` otherwise.
   */
  cacheWillUpdate({request, response} = {}) {
    return this.isResponseCacheable({request, response});
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * # workbox-cacheable-response
 *
 * Given a `Response` object this library determines whether
 * it's "cacheable", based on the response's status code and / or
 * header values.
 *
 * Most develpers will use this module by instantiating a new
 * `CachaebleResponsePlugin` and passing it to a
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper},
 * as shown in the example below.
 *
 * @example <caption>Using the CachaebleResponsePlugin class in a
 * service worker.</caption>
 *
 * // The responses will be cached if the response code is 0, 200, or 404, and
 * // will not be cached otherwise.
 * const cacheablePlugin = new workbox.cacheableResponse.Plugin({
 *   statuses: [0, 200, 404]
 * });
 *
 * const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
 *   cacheName: 'runtime-cache',
 *   plugins: [
 *     cacheablePlugin
 *   ]
 * });
 *
 * const route = new workbox.routing.RegExpRoute({
 *   match: ({url}) => url.domain === 'example.com',
 *   handler: new workbox.runtimeCaching.StaleWhileRevalidate({requestWrapper})
 * });
 *
 * @module workbox-cacheable-response
 */

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * The default cache name, used by
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper} when
 * there's no name provided.
 *
 * It combines a constant prefix with the service worker `scope`, ensuring
 * that multiple service workers used on the same origin will have
 * different default caches.
 *
 * Calling this method without any parameters will return
 * `workbox-runtime-caching-<service worker scope>`.
 *
 * If you pass in a cacheId, it will be prepended, returning:
 * `<cacheid>-workbox-runtime-caching-<service worker scope>`.
 *
 * @param {Object} input
 * @param {string} [input.cacheId] This will be prepended to the default cache
 * name.
 * @return {string} Returns the default cache name used based on optional
 * inputs.
 *
 * @memberof module:workbox-runtime-caching
 */
const getDefaultCacheName = ({cacheId} = {}) => {
  let cacheName = `workbox-runtime-caching`;
  if (cacheId) {
    cacheName = `${cacheId}-${cacheName}`;
  }

  if (self && self.registration) {
   cacheName += `-${self.registration.scope}`;
  }

  return cacheName;
};

/**
 * A list of the callback method names that the RequestWrapper might trigger.
 *
 * @private
 * @type {Array.<string>}
 * @memberof module:workbox-runtime-caching
 */
const pluginCallbacks = [
  'cacheDidUpdate',
  'cachedResponseWillBeUsed',
  'cacheWillUpdate',
  'fetchDidFail',
  'requestWillFetch',
];

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Helper method to "clean" a redirected response, so that it could be used
 * to fulfill a navigation request.
 * See https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
 *
 * @private
 * @param {Object} input
 * @param {Response} input.response The original response. The body will not
 * be consumed.
 * @return {Promise<Response>} A clone of the response, with `redirected` false.
 */
var cleanResponseCopy = ({response}) => {
  isInstance({response}, Response);

  const clonedResponse = response.clone();

  // Not all browsers support the Response.body stream, so fall back to reading
  // the entire body into memory as a blob.
  const bodyPromise = 'body' in clonedResponse ?
    Promise.resolve(clonedResponse.body) :
    clonedResponse.blob();

  return bodyPromise.then((body) => {
    // new Response() is happy when passed either a stream or a Blob.
    return new Response(body, {
      headers: clonedResponse.headers,
      status: clonedResponse.status,
      statusText: clonedResponse.statusText,
    });
  });
};

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Called prior to a response being written to the cache. This allows you to
 * prevent the cache from being updated if the response doesn't meet your
 * custom criteria.
 *
 * @example <caption>Determines whether a response is cacheable based on
 * whether its Cache-Control header contains the string 'no-cache'.</caption>
 *
 * async function cacheWillUpdate({response}) {
 *   return !response.headers.get('cache-control').includes('no-cache');
 * }
 *
 * @callback cacheWillUpdate
 * @param {Object} input
 * @param {Request} input.request The original request.
 * @param {Response} input.response The response to the request, based on the
 * configured strategy.
 * @return {Promise<Boolean>} `true` if the response meets your criteria for
 * being added to the appropriate cache, and `false` if it doesn't.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called after a response has been written to the cache.
 *
 * @example <caption>Logs a message when the cache has been updated.</caption>
 *
 * async function cacheDidUpdate({cacheName, url}) {
 *   console.log(`The entry for ${url} in cache ${cacheName} was updated.`);
 * }
 *
 * @callback cacheDidUpdate
 * @param {Object} input
 * @param {String} input.cacheName The name of the cache that was updated.
 * @param {String} input.url The URL used as a key for the cache.
 * @param {Response|null} input.oldResponse The response that was previously in
 * the cache, prior to the update, or `null` if the cache didn't previously
 * contain an entry for `url`.
 * @param {Response|null} input.newResponse The response that was written to
 * the cache.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called before a previously cached response that has been read from the cache
 * is used. This allows you to modify it or return `null` if it's not valid.
 *
 * @example <caption>Returns `null` to indicate that a cached response shouldn't
 * be used if its Date header is too far in the past.</caption>
 *
 * async function cachedResponseWillBeUsed({cachedResponse}) {
 *   if (cachedResponse) {
 *     const dateHeader = cachedResponse.headers.get('date');
 *     const date = new Date(dateHeader);
 *     if (dateHeader && (Date.now() - date.getTime()) < 1000) {
 *       return cachedResponse;
 *     }
 *   }
 *
 *   return null;
 * }
 *
 * @callback cachedResponseWillBeUsed
 * @param {Object} input
 * @param {Request} input.request The original request.
 * @param {Cache} input.cache An open instance of the cache.
 * @param {String} input.cacheName The name corresponding to `cache`.
 * @param {Response|null} input.cachedResponse The response for `request` that's
 * currently in `cache`, or `null` if there isn't currently a response cached.
 * @param {Object} input.matchOptions The
 * [cache match options](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match#Parameters)
 * that were configured when the current `RequestWrapper` was constructed.
 * @return {Promise<Response|null>} The response to be used as the effective
 * cache match. This might be the same response as `cachedResponse`, if it was
 * valid, a modified version of the response, or `null` if there's no valid
 * match.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called prior to a network request being made. This allows you to update the
 * request's URL or headers as appropriate, or just return the original request
 * if there are no modifications needed.
 *
 * @example <caption>Appends a URL parameter to all outgoing requests.</caption>
 *
 * async function requestWillFetch({request}) {
 *   const url = new URL(request.url);
 *   url.searchParams.set('from-workbox', 'true');
 *   return new Request(url.href, {headers: request.headers});
 * }
 *
 * @callback requestWillFetch
 * @param {Object} input
 * @param {Request} input.request The request that would otherwise have been
 * made against the network.
 * @return {Promise<Request>} The request that will be used against the network
 * instead.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called after a network request has failed. This allows you to report the
 * failure, or save a copy of the failed request to be retried later.
 *
 * @example <caption>Logs a message when a network request fails.</caption>
 *
 * async function fetchDidFail({request}) {
 *   const body = await request.text();
 *   console.log(`A request for ${request.url} with body ${body} failed.`);
 * }
 *
 * @callback fetchDidFail
 * @param {Object} input
 * @param {Request} input.request A clone of the request that failed. You can
 * consume the request's body if needed.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * This class is used by the various subclasses of
 * [Handler]{@link module:workbox-runtime-caching.Handler} to configure the
 * cache name and any desired plugins, which is to say classes that implement
 * request lifecycle callbacks.
 *
 * It automatically triggers any registered callbacks at the appropriate time.
 *
 * @memberof module:workbox-runtime-caching
 */
class RequestWrapper {
  /**
   * Constructor for RequestWrapper.
   * @param {Object} input
   * @param {string} [input.cacheName] The name of the cache to use for Handlers
   *        that involve caching. If none is provided, a default name that
   *        includes the current service worker scope will be used.
   * @param {Array.<Object>} [input.plugins] Any plugins that should be
   *        invoked.
   * @param {Object} [input.fetchOptions] Values passed along to the
   *        [`init`](https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Parameters)
   *        of all `fetch()` requests made by this wrapper.
   * @param {Object} [input.matchOptions] Values passed along to the
   *        [`options`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match#Parameters)
   *        of all cache `match()` requests made by this wrapper.
   */
  constructor({cacheName, cacheId, plugins, fetchOptions, matchOptions} = {}) {
    if (cacheId && (typeof cacheId !== 'string' || cacheId.length === 0)) {
      throw ErrorFactory.createError('bad-cache-id');
    }

    if (cacheName) {
      isType({cacheName}, 'string');
      this.cacheName = cacheName;
      if (cacheId) {
        this.cacheName = `${cacheId}-${this.cacheName}`;
      }
    } else {
      this.cacheName = getDefaultCacheName({cacheId});
    }

    if (fetchOptions) {
      isType({fetchOptions}, 'object');
      this.fetchOptions = fetchOptions;
    }

    if (matchOptions) {
      isType({matchOptions}, 'object');
      this.matchOptions = matchOptions;
    }

    this.plugins = new Map();

    if (plugins) {
      isArrayOfType({plugins}, 'object');

      plugins.forEach((plugin) => {
        for (let callbackName of pluginCallbacks) {
          if (typeof plugin[callbackName] === 'function') {
            if (!this.plugins.has(callbackName)) {
              this.plugins.set(callbackName, []);
            } else if (callbackName === 'cacheWillUpdate') {
              throw ErrorFactory.createError(
                'multiple-cache-will-update-plugins');
            } else if (callbackName === 'cachedResponseWillBeUsed') {
              throw ErrorFactory.createError(
                'multiple-cached-response-will-be-used-plugins');
            }
            this.plugins.get(callbackName).push(plugin);
          }
        }
      });
    }

    if (this.plugins.has('cacheWillUpdate')) {
      this._userSpecifiedCachableResponsePlugin =
        this.plugins.get('cacheWillUpdate')[0];
    }
  }


  /**
   * @private
   * @return {function} The default plugin used to determine whether a
   *         response is cacheable.
   */
  getDefaultCacheableResponsePlugin() {
    // Lazy-construct the CacheableResponsePlugin instance.
    if (!this._defaultCacheableResponsePlugin) {
      this._defaultCacheableResponsePlugin =
        new CacheableResponsePlugin({statuses: [200]});
    }
    return this._defaultCacheableResponsePlugin;
  }

  /**
   * Opens a cache and maintains a reference to that cache
   * for future use.
   *
   * @example
   * requestWrapper.getCache()
   * .then((openCache) => {
   *    ...
   * });
   *
   * @return {Promise<Cache>} An open `Cache` instance based on the configured
   * `cacheName`.
   */
  async getCache() {
    if (!this._cache) {
      this._cache = await caches.open(this.cacheName);
    }
    return this._cache;
  }

  /**
   * Wraps `cache.match()`, using the previously configured cache name and match
   * options.
   *
   * @example
   * requestWrapper.match({event.request})
   * .then((response) => {
   *   if (!response) {
   *     // No response in cache.
   *     return;
   *   }
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The key for the cache lookup.
   * @return {Promise.<Response>} The cached response.
   */
  async match({request}) {
    atLeastOne({request});

    const cache = await this.getCache();
    let cachedResponse = await cache.match(request, this.matchOptions);

    if (this.plugins.has('cachedResponseWillBeUsed')) {
      const plugin = this.plugins.get('cachedResponseWillBeUsed')[0];
      cachedResponse = await plugin.cachedResponseWillBeUsed({
        request, cache, cachedResponse,
        matchOptions: this.matchOptions, cacheName: this.cacheName,
      });
    }

    return cachedResponse;
  }

  /**
   * Wraps `fetch()`, calls all `requestWillFetch` before making the network
   * request, and calls any `fetchDidFail` callbacks from the
   * registered plugins if the request fails.
   *
   * @example
   * requestWrapper.fetch({
   *   request: event.request
   * })
   * .then((response) => {
   *  ...
   * })
   * .catch((err) => {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The request or URL to be fetched.
   * @return {Promise.<Response>} The network response.
   */
  async fetch({request}) {
    if (typeof request === 'string') {
      request = new Request(request);
    } else {
      isInstance({request}, Request);
    }

    // If there is a fetchDidFail plugin, we need to save a clone of the
    // original request before it's either modified by a requestWillFetch
    // plugin or before the original request's body is consumed via fetch().
    const clonedRequest = this.plugins.has('fetchDidFail') ?
      request.clone() : null;

    if (this.plugins.has('requestWillFetch')) {
      for (let plugin of this.plugins.get('requestWillFetch')) {
        const returnedRequest = await plugin.requestWillFetch({request});
        isInstance({returnedRequest}, Request);
        request = returnedRequest;
      }
    }

    try {
      return await fetch(request, this.fetchOptions);
    } catch (err) {
      if (this.plugins.has('fetchDidFail')) {
        for (let plugin of this.plugins.get('fetchDidFail')) {
          await plugin.fetchDidFail({request: clonedRequest.clone()});
        }
      }

      throw err;
    }
  }

  /**
   * Combines both fetching and caching using the previously configured options
   * and calling the appropriate plugins.
   *
   * By default, responses with a status of [2xx](https://fetch.spec.whatwg.org/#ok-status)
   * will be considered valid and cacheable, but this could be overridden by
   * configuring one or more plugins that implement the `cacheWillUpdate`
   * lifecycle callback.
   *
   * @example
   * requestWrapper.fetchAndCache({
   *   request: event.request
   * })
   * .then((response) => {
   *  ...
   * })
   * .catch((err) => {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request} input.request The request to fetch.
   * @param {boolean} [input.waitOnCache] `true` means the method should wait
   *        for the cache.put() to complete before returning. The default value
   *        of `false` means return without waiting. It this value is true
   *        and the response can't be cached, an error will be thrown.
   * @param {Request} [input.cacheKey] Supply a cacheKey if you wish to cache
   *        the response against an alternative request to the `request`
   *        argument.
   * @param {function} [input.cacheResponsePlugin] Allows the
   *        caller to override the default check for cacheability, for
   *        situations in which the cacheability check wasn't explicitly
   *        configured when constructing the `RequestWrapper`.
   * @param {boolean} [input.cleanRedirects] If true, a "clean" copy of any
   * redirected responses will be added to the cache, since redirected responses
   * [can't be used](https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1)
   * to satisfy navigation requests. Defaults to false.
   * @return {Promise.<Response>} The network response.
   */
  async fetchAndCache(
    {request, waitOnCache, cacheKey, cacheResponsePlugin, cleanRedirects}) {
    atLeastOne({request});

    let cachingComplete;
    const response = await this.fetch({request});

    // We need flexibility in determining whether a given response should
    // be added to the cache. There are several possible ways that this logic
    // might be specified, and they're given the following precedence:
    // 1. Passing in a `CacheableResponsePlugin` to the `RequestWrapper`
    //    constructor, which sets this._userSpecifiedCachableResponsePlugin.
    // 2. Passing in a parameter to the fetchAndCache() method (done by certain
    //    runtime handlers, like `StaleWhileRevalidate`), which sets
    //    cacheResponsePlugin.
    // 3. The default that applies to anything using the `RequestWrapper` class
    //    that doesn't specify the custom behavior, which is accessed via
    //    the this.getDefaultCacheableResponsePlugin().
    const effectiveCacheableResponsePlugin =
      this._userSpecifiedCachableResponsePlugin ||
      cacheResponsePlugin ||
      this.getDefaultCacheableResponsePlugin();

    // Whichever plugin we've decided is appropriate, we now call its
    // cacheWillUpdate() method to determine cacheability of the response.
    const cacheable = await effectiveCacheableResponsePlugin.cacheWillUpdate(
      {request, response});

    if (cacheable) {
      // If cleanRedirects is set and this is a redirected response, then
      // get a "clean" copy to add to the cache.
      const newResponse = cleanRedirects && response.redirected ?
        await cleanResponseCopy({response}) :
        response.clone();

      // cachingComplete is a promise that may or may not be used to delay the
      // completion of this method, depending on the value of `waitOnCache`.
      cachingComplete = this.getCache().then(async (cache) => {
        let oldResponse;
        const cacheRequest = cacheKey || request;

        // Only bother getting the old response if the new response isn't opaque
        // and there's at least one cacheDidUpdate plugin. Otherwise, we don't
        // need it.
        if (response.type !== 'opaque' &&
          this.plugins.has('cacheDidUpdate')) {
          oldResponse = await this.match({request: cacheRequest});
        }

        // Regardless of whether or not we'll end up invoking
        // cacheDidUpdate, wait until the cache is updated.
        await cache.put(cacheRequest, newResponse);

        if (this.plugins.has('cacheDidUpdate')) {
          for (let plugin of this.plugins.get('cacheDidUpdate')) {
            await plugin.cacheDidUpdate({
              cacheName: this.cacheName,
              oldResponse,
              newResponse,
              // cacheRequest may be a Request with a url property, or a string.
              url: ('url' in cacheRequest) ? cacheRequest.url : cacheRequest,
            });
          }
        }
      });
    } else if (!cacheable && waitOnCache) {
      // If the developer requested to wait on the cache but the response
      // isn't cacheable, throw an error.
      throw ErrorFactory.createError('invalid-response-for-caching');
    }

    // Only conditionally await the caching completion, giving developers the
    // option of returning early for, e.g., read-through-caching scenarios.
    if (waitOnCache && cachingComplete) {
      await cachingComplete;
    }

    return response;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * # workbox-runtime-caching
 *
 * A service worker helper library that implements various runtime caching
 * strategies.
 *
 * You can learn more about each caching strategy on
 * {@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/|Jake Archibald's blog post}
 * which covers various ways of handling fetch events with a service worker.
 *
 * These strategies can be used as the
 * [handler parameter in the Route constructor]{@link
 * module:workbox-routing.Route} or as the
 * [handler parameter in workboxSW.router.registerRoute()]{@link
 * module:workbox-sw.Router#registerRoute}.
 *
 * @module workbox-runtime-caching
 */

const ERRORS = {
  'not-in-sw': {
    message: 'workbox-precaching must be loaded in your service worker file.',
  },
  'invalid-object-entry': {
    message: (context) => {
      return `Precache entries entered as an object must have a 'url' and ` +
      `'revision' parameter. The '${context.problemParam}' parameter has an ` +
      `invalid value of '${context.problemValue}'.`;
    },
  },
  'invalid-string-entry': {
    message: (context) => {
      return `Precache entries entered as strings must have at least ` +
        `one character. Received url of '${context.url}'`;
    },
  },
  'invalid-request-entry': {
    message: (context) => {
      return `Precache entry was coerced as a RequestCacheEntry but the type ` +
        `received was not a Request. Received url of '${context.url}'`;
    },
  },
  'bad-cache-bust': {
    message: `The cache bust parameter must be a boolean.`,
  },
  'duplicate-entry-diff-revisions': {
    message: (context) => {
      return `An attempt was made to cache the same ` +
        `url twice with each having different revisions. This is not ` +
        `supported. First entry was: ` +
        `'${JSON.stringify(context.firstEntry)}' and the second entry was ` +
        `'${JSON.stringify(context.secondEntry)}'`;
    },
  },
  'request-not-cached': {
    message: (context) => {
      return `The request fpr '${context.url}' failed the criteria to be ` +
        `cached. By default, only responses with 'response.ok = true' ` +
        `are cached.`;
    },
  },
  'requires-overriding': {
    message: 'Method should be overridden by the extending class.',
  },
  'bad-cache-id': {
    message: (context) => {
      return `The 'cacheId' parameter must be a string with at least ` +
      `one character. Received '${JSON.stringify(context.cacheId)}'.`;
    },
  },
  'unexpected-precache-entry': {
    message: (context) => {
      return `One of the precache entries had an unexpected type of: ` +
      `'${typeof context.input}'`;
    },
  },
};

const errorMessageFactory = (code, context) => {
  const errorDetails = ERRORS[code];
  if (!errorDetails) {
    return `An error was thrown by workbox with error code: '${code}'.`;
  }

  const errorMessage = typeof errorDetails.message === 'function' ?
    errorDetails.message(context) :
    errorDetails.message;
  return errorMessage.replace(/\s+/g, ' ');
};

/**
 * This is a class for managing errors thrown by Workbox.
 *
 * This class will have full fat error messages in dev builds
 * and be slimmed down in prod.
 */
class WorkboxError extends Error {
  /**
   * Construct a new Workbox Error Message.
   * @param {String} errorCode The error code that is associated with the
   * error message and will be used to generate the appropriate error message.
   * @param {Object} [extras] These are fields that will be passed to
   * the error message to be included if the message wants and exposed
   * under `err.extra` should the developer need to access the information.
   */
  constructor(errorCode, extras) {
    super();

    this.name = errorCode;
    this.message = errorMessageFactory(errorCode, extras);

    if (extras) {
      this.extras = extras;
    }
  }
}

/**
 * This class handles the shared logic for caching revisioned and unrevisioned
 * assets.
 *
 * @memberof module:workbox-precaching
 */
class BaseCacheManager {
  /**
   * Constructor for BaseCacheManager
   *
   * @param {Object} input
   * @param {String} [input.cacheName] This is the cache name to store requested
   * assets.
   * @param {String} [input.cacheId] The cacheId can be used to ensure that
   * multiple projects sharing `http://localhost` have unique cache names.
   * @param {Array<Object>} [input.plugins] Any plugins that should be
   * invoked by the underlying `RequestWrapper`.
   */
  constructor({cacheName, cacheId, plugins} = {}) {
    if (cacheId && (typeof cacheId !== 'string' || cacheId.length === 0)) {
      throw new WorkboxError('bad-cache-id', {cacheId});
    }

    this._entriesToCache = new Map();
    this._requestWrapper = new RequestWrapper({
      cacheName,
      cacheId,
      plugins,
      fetchOptions: {
        credentials: 'same-origin',
      },
    });
  }

  /**
   * Adds entries to the install list.
   * This will manage duplicate entries and perform the caching during
   * the install step.
   *
   * @private
   * @param {Array<String|Request|Object>} rawEntries A raw entry that can be
   * parsed into a BaseCacheEntry by the inheriting CacheManager.
   */
  _addEntries(rawEntries) {
    this._parsedCacheUrls = null;

    rawEntries.forEach((rawEntry) => {
      this._addEntryToInstallList(
        this._parseEntry(rawEntry)
      );
    });
  }

  /**
   * Gives access to the cache name used by this caching manager.
   * @return {String} The cache name used by this manager.
   */
  getCacheName() {
    return this._requestWrapper.cacheName;
  }

  /**
   * Returns an array of fully qualified URL's that will be cached by this
   * cache manager.
   *
   * @return {Array<String>} An array of URLs that will be cached.
   */
  getCachedUrls() {
    if (!this._parsedCacheUrls) {
      this._parsedCacheUrls = Array.from(this._entriesToCache.keys())
        .map((url) => new URL(url, location).href);
    }

    return this._parsedCacheUrls;
  }

  /**
   * Adds an entry to the install list.
   *
   * Duplicates are filtered out and checks are made for the scenario
   * where two entries have the same URL but different revisions. For example
   * caching:
   * [
   *   {url: '/hello.txt', revision: 'abcd1234'},
   *   {url: '/hello.txt', revision: 'efgh5678'},
   * ]
   * This will throw an error as the library can't determine the correct
   * revision and this may cause issues in future when updating the service
   * worker with new revisions.
   *
   * @private
   * @param {RevisionedCacheEntry} precacheEntry The file entry to be cached
   * during the next install event.
   */
  _addEntryToInstallList(precacheEntry) {
    const entryID = precacheEntry.entryID;
    const previousEntry = this._entriesToCache.get(precacheEntry.entryID);
    if (!previousEntry) {
      // This entry isn't in the install list
      this._entriesToCache.set(entryID, precacheEntry);
      return;
    }

    this._onDuplicateInstallEntryFound(precacheEntry, previousEntry);
  }

  /**
   * This method will go through each asset added to the cache list and
   * fetch and update the cache for assets which have a new revision hash.
   *
   * @return {Promise<Array<Object>>} The promise resolves when all the
   * desired assets are cached and up -to-date.
   */
  async install() {
    if (this._entriesToCache.size === 0) {
      return [];
    }

    const cachePromises = [];
    this._entriesToCache.forEach((precacheEntry) => {
      cachePromises.push(
        this._cacheEntry(precacheEntry)
      );
    });

    // Wait for all requests to be cached.
    return Promise.all(cachePromises);
  }

  /**
   * Requests the entry and saves it to the cache if the response
   * is valid.
   *
   * @private
   * @param {BaseCacheEntry} precacheEntry The entry to fetch and cache.
   * @return {Promise<Object>} Returns a promise that resolves once the entry
   * has been fetched and cached or skipped if no update is needed. The
   * promise resolved with details of the entry and whether it was
   * updated or not.
   */
  async _cacheEntry(precacheEntry) {
    const isCached = await this._isAlreadyCached(precacheEntry);
    const precacheDetails = {
      url: precacheEntry.request.url,
      revision: precacheEntry.revision,
      wasUpdated: !isCached,
    };
    if (isCached) {
      return precacheDetails;
    }

    try {
      await this._requestWrapper.fetchAndCache({
        request: precacheEntry.getNetworkRequest(),
        waitOnCache: true,
        cacheKey: precacheEntry.request,
        cleanRedirects: true,
      });

      await this._onEntryCached(precacheEntry);
      return precacheDetails;
    } catch (err) {
      throw new WorkboxError('request-not-cached', {
        url: precacheEntry.request.url,
        error: err,
      });
    }
  }

  /**
   * Compare the URL's and determines which assets are no longer required
   * in the cache.
   *
   * This should be called in the service worker activate event.
   *
   * @return {Promise} Promise that resolves once the cache entries have been
   * cleaned.
   */
  async cleanup() {
    if (!await caches.has(this.getCacheName())) {
      // Cache doesn't exist, so nothing to delete
      return;
    }

    const requestsCachedOnInstall = [];
    this._entriesToCache.forEach((entry) => {
      requestsCachedOnInstall.push(entry.request.url);
    });

    const openCache = await this._getCache();
    const allCachedRequests = await openCache.keys();

    const cachedRequestsToDelete = allCachedRequests.filter(
      (cachedRequest) => !requestsCachedOnInstall.includes(cachedRequest.url));

    return Promise.all(
      cachedRequestsToDelete.map(async (cachedRequest) => {
        await openCache.delete(cachedRequest);
        await this._onEntryDeleted(cachedRequest.url);
      })
    );
  }

  /**
   * A simple helper method to get the open cache used for precaching assets.
   *
   * @private
   * @return {Promise<Cache>} The cache to be used for precaching.
   */
  async _getCache() {
    if (!this._cache) {
      this._cache = await caches.open(this.getCacheName());
    }

    return this._cache;
  }

  /**
   * Ensures the file entry in the maniest is valid and
   * can be parsed as a BaseCacheEntry.
   *
   * @private
   * @abstract
   * @param {String | Request | Object} input Either a URL string, a Request
   * or an object with a `url`, `revision` and optional `cacheBust` parameter.
   * @return {BaseCacheEntry} Returns a parsed version of the file entry.
   */
  _parseEntry(input) {
    throw new WorkboxError('requires-overriding');
  }

  /**
   * Called in case subclasses have cache entries that are to be installed
   * but have the same "entryID".
   * This means that the user is trying to cache the same thing twice.
   * Subclasses can use this method to throw an error if there is an edge
   * case that can't be handled.
   *
   * @private
   * @abstract
   * @param {BaseCacheEntry} newEntry The entry that is to be cached.
   * @param {BaseCacheEntry} previous The entry that is currently cached.
   */
  _onDuplicateEntryFound(newEntry, previous) {
    throw new WorkboxError('requires-overriding');
  }

  /**
   * Confirms whether a fileEntry is already in the cache with the
   * appropriate revision or not.
   *
   * @private
   * @abstract
   * @param {BaseCacheEntry} precacheEntry A file entry with `path` and
   * `revision` parameters.
   * @return {Promise<Boolean>} Returns true is the fileEntry is already
   * cached, false otherwise.
   */
  _isAlreadyCached(precacheEntry) {
    throw new WorkboxError('requires-overriding');
  }

  /**
   * Subclasses can use this method for any work that needs to be done once a
   * URL has been cached.
   *
   * @private
   * @abstract
   * @param {BaseCacheEntry} precacheEntry A file entry with `path` and
   * `revision` parameters.
   * @return {Promise} Returns a Promise that resolves once it's work has
   * been done.
   */
  _onEntryCached(precacheEntry) {
    throw new WorkboxError('requires-overriding');
  }

  /**
   * Subclasses can use this method for any work that needs to be done once a
   * URL has been deleted from the cache.
   *
   * @private
   * @abstract
   * @param {String} url The URL of the entry that was deleted.
   * @return {Promise} Returns a Promise that resolves once the work is done.
   */
  _onEntryDeleted(url) {
    throw new WorkboxError('requires-overriding');
  }
}

var idb = createCommonjsModule(function (module) {
'use strict';

(function() {
  function toArray(arr) {
    return Array.prototype.slice.call(arr);
  }

  function promisifyRequest(request) {
    return new Promise(function(resolve, reject) {
      request.onsuccess = function() {
        resolve(request.result);
      };

      request.onerror = function() {
        reject(request.error);
      };
    });
  }

  function promisifyRequestCall(obj, method, args) {
    var request;
    var p = new Promise(function(resolve, reject) {
      request = obj[method].apply(obj, args);
      promisifyRequest(request).then(resolve, reject);
    });

    p.request = request;
    return p;
  }

  function promisifyCursorRequestCall(obj, method, args) {
    var p = promisifyRequestCall(obj, method, args);
    return p.then(function(value) {
      if (!value) return;
      return new Cursor(value, p.request);
    });
  }

  function proxyProperties(ProxyClass, targetProp, properties) {
    properties.forEach(function(prop) {
      Object.defineProperty(ProxyClass.prototype, prop, {
        get: function() {
          return this[targetProp][prop];
        },
        set: function(val) {
          this[targetProp][prop] = val;
        }
      });
    });
  }

  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return this[targetProp][prop].apply(this[targetProp], arguments);
      };
    });
  }

  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyCursorRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function Index(index) {
    this._index = index;
  }

  proxyProperties(Index, '_index', [
    'name',
    'keyPath',
    'multiEntry',
    'unique'
  ]);

  proxyRequestMethods(Index, '_index', IDBIndex, [
    'get',
    'getKey',
    'getAll',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
    'openCursor',
    'openKeyCursor'
  ]);

  function Cursor(cursor, request) {
    this._cursor = cursor;
    this._request = request;
  }

  proxyProperties(Cursor, '_cursor', [
    'direction',
    'key',
    'primaryKey',
    'value'
  ]);

  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
    'update',
    'delete'
  ]);

  // proxy 'next' methods
  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {
    if (!(methodName in IDBCursor.prototype)) return;
    Cursor.prototype[methodName] = function() {
      var cursor = this;
      var args = arguments;
      return Promise.resolve().then(function() {
        cursor._cursor[methodName].apply(cursor._cursor, args);
        return promisifyRequest(cursor._request).then(function(value) {
          if (!value) return;
          return new Cursor(value, cursor._request);
        });
      });
    };
  });

  function ObjectStore(store) {
    this._store = store;
  }

  ObjectStore.prototype.createIndex = function() {
    return new Index(this._store.createIndex.apply(this._store, arguments));
  };

  ObjectStore.prototype.index = function() {
    return new Index(this._store.index.apply(this._store, arguments));
  };

  proxyProperties(ObjectStore, '_store', [
    'name',
    'keyPath',
    'indexNames',
    'autoIncrement'
  ]);

  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'put',
    'add',
    'delete',
    'clear',
    'get',
    'getAll',
    'getKey',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'openCursor',
    'openKeyCursor'
  ]);

  proxyMethods(ObjectStore, '_store', IDBObjectStore, [
    'deleteIndex'
  ]);

  function Transaction(idbTransaction) {
    this._tx = idbTransaction;
    this.complete = new Promise(function(resolve, reject) {
      idbTransaction.oncomplete = function() {
        resolve();
      };
      idbTransaction.onerror = function() {
        reject(idbTransaction.error);
      };
      idbTransaction.onabort = function() {
        reject(idbTransaction.error);
      };
    });
  }

  Transaction.prototype.objectStore = function() {
    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };

  proxyProperties(Transaction, '_tx', [
    'objectStoreNames',
    'mode'
  ]);

  proxyMethods(Transaction, '_tx', IDBTransaction, [
    'abort'
  ]);

  function UpgradeDB(db, oldVersion, transaction) {
    this._db = db;
    this.oldVersion = oldVersion;
    this.transaction = new Transaction(transaction);
  }

  UpgradeDB.prototype.createObjectStore = function() {
    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };

  proxyProperties(UpgradeDB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
    'deleteObjectStore',
    'close'
  ]);

  function DB(db) {
    this._db = db;
  }

  DB.prototype.transaction = function() {
    return new Transaction(this._db.transaction.apply(this._db, arguments));
  };

  proxyProperties(DB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(DB, '_db', IDBDatabase, [
    'close'
  ]);

  // Add cursor iterators
  // TODO: remove this once browsers do the right thing with promises
  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {
    [ObjectStore, Index].forEach(function(Constructor) {
      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {
        var args = toArray(arguments);
        var callback = args[args.length - 1];
        var nativeObject = this._store || this._index;
        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
        request.onsuccess = function() {
          callback(request.result);
        };
      };
    });
  });

  // polyfill getAll
  [Index, ObjectStore].forEach(function(Constructor) {
    if (Constructor.prototype.getAll) return;
    Constructor.prototype.getAll = function(query, count) {
      var instance = this;
      var items = [];

      return new Promise(function(resolve) {
        instance.iterateCursor(query, function(cursor) {
          if (!cursor) {
            resolve(items);
            return;
          }
          items.push(cursor.value);

          if (count !== undefined && items.length == count) {
            resolve(items);
            return;
          }
          cursor.continue();
        });
      });
    };
  });

  var exp = {
    open: function(name, version, upgradeCallback) {
      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);
      var request = p.request;

      request.onupgradeneeded = function(event) {
        if (upgradeCallback) {
          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
        }
      };

      return p.then(function(db) {
        return new DB(db);
      });
    },
    delete: function(name) {
      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
    }
  };

  {
    module.exports = exp;
    module.exports.default = module.exports;
  }
}());
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable require-jsdoc */

/**
 * A wrapper to store for an IDB connection to a particular ObjectStore.
 *
 * @private
 */
class IDBHelper {
  constructor(name, version, storeName) {
    if (name == undefined || version == undefined || storeName == undefined) {
      throw Error('name, version, storeName must be passed to the ' +
        'constructor.');
    }

    this._name = name;
    this._version = version;
    this._storeName = storeName;
  }

  /**
   * Returns a promise that resolves with an open connection to IndexedDB,
   * either existing or newly opened.
   *
   * @private
   * @return {Promise<DB>}
   */
  _getDb() {
    if (this._dbPromise) {
      return this._dbPromise;
    }

    this._dbPromise = idb.open(this._name, this._version, (upgradeDB) => {
      upgradeDB.createObjectStore(this._storeName);
    })
    .then((db) => {
      return db;
    });

    return this._dbPromise;
  }

  close() {
    if (!this._dbPromise) {
      return;
    }

    return this._dbPromise
    .then((db) => {
      db.close();
      this._dbPromise = null;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies saving the key/value
   * pair to the object store.
   * Returns a Promise that fulfills when the transaction completes.
   *
   * @private
   * @param {String} key
   * @param {Object} value
   * @return {Promise<T>}
   */
  put(key, value) {
    return this._getDb().then((db) => {
      const tx = db.transaction(this._storeName, 'readwrite');
      const objectStore = tx.objectStore(this._storeName);
      objectStore.put(value, key);
      return tx.complete;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies deleting an entry
   * from the object store.
   * Returns a Promise that fulfills when the transaction completes.
   *
   * @private
   * @param {String} key
   * @return {Promise<T>}
   */
  delete(key) {
    return this._getDb().then((db) => {
      const tx = db.transaction(this._storeName, 'readwrite');
      const objectStore = tx.objectStore(this._storeName);
      objectStore.delete(key);
      return tx.complete;
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting a key's value
   * from the object store.
   * Returns a promise that fulfills with the value.
   *
   * @private
   * @param {String} key
   * @return {Promise<Object>}
   */
  get(key) {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .get(key);
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting all the values
   * in an object store.
   * Returns a promise that fulfills with all the values.
   *
   * @private
   * @return {Promise<Array<Object>>}
   */
  getAllValues() {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .getAll();
    });
  }

  /**
   * Wrapper on top of the idb wrapper, which simplifies getting all the keys
   * in an object store.
   * Returns a promise that fulfills with all the keys.
   *
   * @private
   * @param {String} storeName
   * @return {Promise<Array<Object>>}
   */
  getAllKeys() {
    return this._getDb().then((db) => {
      return db.transaction(this._storeName)
        .objectStore(this._storeName)
        .getAllKeys();
    });
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

const cacheBustParamName = '_workbox-precaching';
const version = 'v1';
const dbName = 'workbox-precaching';
const dbVersion = '1';
const dbStorename = 'asset-revisions';

let tmpRevisionedCacheName = `workbox-precaching-revisioned-${version}`;
if (self && self.registration) {
  tmpRevisionedCacheName += `-${self.registration.scope}`;
}
const defaultRevisionedCacheName = tmpRevisionedCacheName;

/**
 * This class is a simple model that stores EntryID's with their current
 * revision. This is used when caching revisioned assets so that only entries
 * with different revisions are downloaded and updated.
 *
 * @private
 * @memberof module:workbox-precaching
 */
class RevisionDetailsModel {
  /**
   * Constructor for RevisionDetails Model.
   */
  constructor() {
    this._idbHelper = new IDBHelper(dbName, dbVersion, dbStorename);
  }

  /**
   * This method gets the revision details for a given entryID.
   * @param {String} entryID The ID of the revision.
   * @return {Promise<String|null>} Returns a revision string or
   * null if there is no revision information.
   */
  get(entryID) {
    return this._idbHelper.get(entryID);
  }

  /**
   * This method saves the revision details to indexedDB.
   * @param {String} entryID The ID of the revision.
   * @param {String} revision The current revision for this entryID.
   * @return {Promise} Promise that resolves once the data has been saved.
   */
  put(entryID, revision) {
    return this._idbHelper.put(entryID, revision);
  }

  /**
   * This method deletes the revision details from indexedDB for a given entry.
   * @param {String} entryID The ID of the revision.
   * @return {Promise} Promise that resolves once the data has been deleted.
   */
  delete(entryID) {
    return this._idbHelper.delete(entryID);
  }

  /**
   * This method closes the indexdDB helper. This is only used for unit testing
   * to ensure clean state between tests.
   *
   * @private
   */
  _close() {
    this._idbHelper.close();
  }
}

/**
 * This class is extended by a number of classes that take different inputs
 * and generates the required fields for a BaseCacheEntry.
 *
 * @private
 * @memberof module:workbox-precaching
 */
class BaseCacheEntry {
  /**
   * This constructor expects an object and a number or required fields.
   * You shouldn't need to use this constructor directly.
   *
   * @param {Object} input
   * @param {String} input.entryID
   * @param {String} input.revision
   * @param {Request} input.request
   * @param {boolean} input.cacheBust
   */
  constructor({entryID, revision, request, cacheBust}) {
    this.entryID = entryID;
    this.revision = revision;
    this.request = request;
    this.cacheBust = cacheBust;
  }

  /**
   * This method is required since any revisioned request needs to cache bust.
   * To ensure this is consistent, CacheManagers will make a network request
   * using this specially formatted request.
   *
   * When caching the response, it will be cached against the origin `request`,
   * removing lookup for the cachebusted URL.
   *
   * @return {Request} Returns a cache busted request if needed, otherwise
   * a normal request with credentials set to 'same-origin' and redirect set to
   * follow.
   */
  getNetworkRequest() {
    if (this.cacheBust !== true) {
      // For the RequestCacheEntry we should return it to ensure headers are
      // kept in tact and part of the request.
      return this.request;
    }

    let url = this.request.url;
    const requestOptions = {};

    if (this.cacheBust === true) {
      if ('cache' in Request.prototype) {
        // Make use of the Request cache mode where we can.
        // Reload skips the HTTP cache for outgoing requests and updates
        // the cache with the returned reponse.
        requestOptions.cache = 'reload';
      } else {
        const parsedURL = new URL(url, location);
        parsedURL.search += (parsedURL.search ? '&' : '') +
          encodeURIComponent(cacheBustParamName) + '=' +
          encodeURIComponent(this.revision);
        url = parsedURL.toString();
      }
    }

    return new Request(url, requestOptions);
  }
}

/**
 * This class will take a string and parse it as a BaseCacheEntry.
 *
 * @private
 * @memberof module:workbox-precaching
 * @extends {module:workbox-precaching.BaseCacheEntry}
 */
class StringCacheEntry extends BaseCacheEntry {
  /**
   * Cosntructor for StringCacheEntry.
   *
   * @param {String} url A URL to cache.
   */
  constructor(url) {
    isType({url}, 'string');
    if (url.length === 0) {
      throw new WorkboxError('invalid-string-entry', {
        url,
      });
    }

    super({
      entryID: url,
      revision: url,
      request: new Request(url),
      cacheBust: false,
    });
  }
}

/**
 * This class will take an object of parameters, validate the input and
 * parse to be used as a BaseCacheEntry.
 *
 * @private
 * @memberof module:workbox-precaching
 * @extends {module:workbox-precaching.BaseCacheEntry}
 */
class ObjectCacheEntry extends BaseCacheEntry {
  /**
   * This class gives most control over configuring a cache entry.
   * @param {Object} input
   * @param {String} [input.entryID] The ID of the entry. This is the key used
   * with IndexDB to store the revision. Normally this is just the URL.
   * @param {String} [input.revision] This is the revision associated with this
   * URL.
   * @param {String} input.url The URL to cache.
   * @param {boolean} [input.cacheBust] A boolean to indicate if this request
   * will require cache busting (i.e. the URL is not unique between SW install).
   */
  constructor({entryID, revision, url, cacheBust}) {
    if (typeof revision !== 'undefined') {
      isType({revision}, 'string');
      if (revision.length === 0) {
        throw new WorkboxError('invalid-object-entry',
          {problemParam: 'revision', problemValue: revision});
      }
    }

    if (typeof cacheBust === 'undefined') {
      // If the cacheBust value is not explicitly set, then set it to true
      // if there's a revision provided, and false if there's no revision.
      cacheBust = Boolean(revision);
    }
    isType({cacheBust}, 'boolean');

    isType({url}, 'string');
    if (url.length === 0) {
      throw new WorkboxError('invalid-object-entry',
        {problemParam: 'url', problemValue: url});
    }

    if (typeof entryID === 'undefined') {
      entryID = new URL(url, location).toString();
    } else {
      if (entryID.length === 0) {
        throw new WorkboxError('invalid-object-entry',
          {problemParam: 'entryID', problemValue: entryID});
      }
    }

    super({
      entryID,
      // If revision isn't set, assume that the URL contains revision info.
      revision: revision || url,
      request: new Request(url),
      cacheBust,
    });
  }
}

/**
 * You can instantiate this class to add requests to a precache list and
 * eventually install the assets by calling [install()]{@link
 * module:workbox-precaching.BaseCacheManager#install} and to remove
 * old entries call [cleanup()]{@link
 *  module:workbox-precaching.RevisionedCacheManager#cleanup}.
 *
 * @memberof module:workbox-precaching
 * @extends module:workbox-precaching.BaseCacheManager
 */
class RevisionedCacheManager extends BaseCacheManager {
  /**
   * Constructs a new RevisionedCacheManager to handle caching of revisioned
   * assets only.
   *
   * @param {Object} input
   * @param {String} [input.cacheName] The cache to be used for precaching.
   * @param {String} [input.cacheId] The cacheId is prepended to the
   * cache name. This is useful if you have multiple projects sharing
   * the same `http://localhost` origin and want unique cache names.
   * @param {Array<Object>} [input.plugins] Any plugins that should be
   * invoked by the underlying `RequestWrapper`.
   */
  constructor(input = {}) {
    input.cacheName = input.cacheName || defaultRevisionedCacheName;

    super(input);

    this._revisionDetailsModel = new RevisionDetailsModel();
  }

  /**
   * This method will add the supplied entries to the install list and
   * can be called multiple times.
   *
   * The `revisionedFiles` parameter of the input should contain an array
   * of objects or strings.
   *
   * Objects in this array should have a `url` and `revision` parameter where
   * the revision is a hash, unique to the files contents, which changes
   * whenever the file is updated. (See our [getting started guide to learn
   * how to automate this](/#get-started)).
   *
   * Strings should be URL's that contain revisioning information
   * i.e. `/styles/main.abcd.css` instead of `/styles/main.css`. If you supply
   * a URL which *isn't* revisioned, the `install()` step will **never** update
   * the precached asset.
   *
   * @param {Object} input
   * @param {Array<String|Object>} input.revisionedFiles This should be an
   * array of either objects or strings.
   *
   * @example
   * revisionedManager.addToCacheList({
   *   revisionedFiles: [
   *     '/styles/hello.1234.css',
   *     {
   *       url: '/images/logo.png',
   *       revision: 'abcd1234'
   *     }
   *   ]
   * });
   */
  addToCacheList({revisionedFiles} = {}) {
    isInstance({revisionedFiles}, Array);
    super._addEntries(revisionedFiles);

    const urlsWithoutRevisionFields = revisionedFiles
      .filter((entry) => typeof entry === 'string' || !entry.revision);
    if (urlsWithoutRevisionFields.length > 0) {
      logHelper.debug({
        that: this,
        message: `Some precache entries are URLs without separate revision
          fields. If the URLs themselves do not contain revisioning info,
          like a hash or a version number, your users won't receive updates.`,
        data: {
          'URLs without revision fields':
            JSON.stringify(urlsWithoutRevisionFields),
          'Examples of safe, versioned URLs':
            `'/path/file.abcd1234.css' or '/v1.0.0/file.js'`,
          'Examples of dangerous, unversioned URLs':
            `'index.html' or '/path/file.css' or '/latest/file.js'`,
        },
      });
    }
  }

  /**
   * This method ensures that the file entry in the maniest is valid and
   * can be parsed as a BaseCacheEntry.
   *
   * @private
   * @param {String | Object} input Either a URL string or an object with a
   * `url` and optional `revision` and `cacheBust` parameters.
   * @return {BaseCacheEntry} Returns a parsed version of the file entry.
   */
  _parseEntry(input) {
    if (input === null) {
      throw new WorkboxError('unexpected-precache-entry', {input});
    }

    let precacheEntry;
    switch (typeof input) {
      case 'string':
        precacheEntry = new StringCacheEntry(input);
        break;
      case 'object':
        precacheEntry = new ObjectCacheEntry(input);
        break;
      default:
        throw new WorkboxError('unexpected-precache-entry', {input});
    }

    return precacheEntry;
  }

  /**
   * If a dupe entry exists, check the revision. If the revisions are the same
   * it's simply a duplicate entry. If they are different, we have two
   * identical requests with two different revisions which will put this
   * module into a bad state.
   *
   * @private
   * @param {BaseCacheEntry} newEntry The entry that is to be cached.
   * @param {BaseCacheEntry} previousEntry The entry that is currently cached.
   */
  _onDuplicateInstallEntryFound(newEntry, previousEntry) {
    if (previousEntry.revision !== newEntry.revision) {
      throw new WorkboxError('duplicate-entry-diff-revisions', {
        firstEntry: {
          url: previousEntry.request.url,
          revision: previousEntry.revision,
        },
        secondEntry: {
          url: newEntry.request.url,
          revision: newEntry.revision,
        },
      });
    }
  }

  /**
   * This method confirms with a precacheEntry is already in the cache with the
   * appropriate revision.
   * If the revision is known, the requested `precacheEntry.revision` is saved
   * and the cache entry exists for the `precacheEntry.path` this method
   * will return true.
   *
   * @private
   * @param {BaseCacheEntry} precacheEntry A entry with `path` and `revision`
   * parameters.
   * @return {Promise<Boolean>} Returns true if the precacheEntry is already
   * cached, false otherwise.
   */
  async _isAlreadyCached(precacheEntry) {
    const revisionDetails = await
      this._revisionDetailsModel.get(precacheEntry.entryID);
    if (revisionDetails !== precacheEntry.revision) {
      return false;
    }

    const openCache = await this._getCache();
    const cachedResponse = await openCache.match(precacheEntry.request);
    return cachedResponse ? true : false;
  }

  /**
   * @private
   * @param {BaseCacheEntry} precacheEntry A file entry with `path` and
   * `revision` parameters.
   */
  async _onEntryCached(precacheEntry) {
    await this._revisionDetailsModel.put(
      precacheEntry.entryID, precacheEntry.revision);
  }

  /**
   * Removes a URL from IndexedDB when the corresponding entry has been removed
   * from the Cache Storage API.
   *
   * @private
   * @param {String} url The URL that has been deleted from the cache.
   */
  async _onEntryDeleted(url) {
    await this._revisionDetailsModel.delete(url);
  }

  /**
   * This method closes the indexdDB helper. This is used for unit testing
   * to ensure cleanup between tests.
   * @private
   */
  _close() {
    this._revisionDetailsModel._close();
  }

  /**
   * This method will compare the currently cached requests's and determine
   * which requests are no longer in the cache list and can be removed from the
   * cache.
   *
   * This should be called in a service worker's activate event to avoid
   * removing requests that are still be used by currently open pages.
   *
   * @return {Promise} Promise that resolves once the cache entries have been
   * cleaned.
   */
  cleanup() {
    return super.cleanup()
    .then(() => {
      return this._close();
    });
  }

  /**
   * Given an array of objects with a 'url', 'revision' value this
   * method will create a friendly string to log.
   * @private
   * @param {Array<Object>} allCacheDetails
   * @return {String} A log friendly string.
   */
  _createLogFriendlyString(allCacheDetails) {
    let stringVersion = `\n`;
    allCacheDetails.forEach((cacheDetails) => {
      stringVersion += `    URL: '${cacheDetails.url}' Revision: ` +
        `'${cacheDetails.revision}'\n`;
    });
    return stringVersion;
  }

  /**
   * This method will go through each asset added to the cache list and
   * fetch and update the cache for assets which have a new revision hash.
   *
   * @return {Promise<Array<Object>>} The promise resolves when all the
   * desired assets are cached and up -to-date.
   */
  install() {
    return super.install()
    .then((allCacheDetails) => {
      const updatedCacheDetails = [];
      const notUpdatedCacheDetails = [];
      allCacheDetails.forEach((cacheDetails) => {
        if (cacheDetails.wasUpdated) {
          updatedCacheDetails.push({
            url: cacheDetails.url,
            revision: cacheDetails.revision,
          });
        } else {
          notUpdatedCacheDetails.push({
            url: cacheDetails.url,
            revision: cacheDetails.revision,
          });
        }
      });

      const logData = {};
      if (updatedCacheDetails.length > 0) {
        logData['New / Updated Precache URL\'s'] =
          this._createLogFriendlyString(updatedCacheDetails);
      }

      if (notUpdatedCacheDetails.length > 0) {
        logData['Up-to-date Precache URL\'s'] =
          this._createLogFriendlyString(notUpdatedCacheDetails);
      }

      logHelper.log({
        message: `Precache Details: ${updatedCacheDetails.length} requests ` +
        `were added or updated and ` +
        `${notUpdatedCacheDetails.length} request are already ` +
        `cached and up-to-date.`,
        data: logData,
      });

      return allCacheDetails;
    });
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe(`Test Library Surface`, function() {
  it(`should be able to get the revisioned cache manager`, function() {
    const revisionedManager = new RevisionedCacheManager();

    const cacheName = revisionedManager.getCacheName();
    if (!cacheName || typeof cacheName !== 'string' || cacheName.length === 0) {
      throw new Error('Unexpected cache name: ' + cacheName);
    }

    let cacheUrls = revisionedManager.getCachedUrls();
    if (!Array.isArray(cacheUrls) || cacheUrls.length !== 0) {
      throw new Error('Unexpected cacheUrls value: ' + JSON.stringify(cacheUrls));
    }

    const URL_1 = '/';
    const URL_2 = '/__echo/date/example.1234.txt';
    revisionedManager.addToCacheList({
      revisionedFiles: [
        {
          url: URL_1,
          revision: '1234',
        },
        URL_2,
      ],
    });

    cacheUrls = revisionedManager.getCachedUrls();
    if (!Array.isArray(cacheUrls) || cacheUrls.length !== 2) {
      throw new Error('Unexpected cacheUrls value: ' + JSON.stringify(cacheUrls));
    }

    const urlsToFind = [URL_1, URL_2];
    urlsToFind.forEach((urlToFind) => {
      if (cacheUrls.indexOf(new URL(urlToFind, location).href) === -1) {
        throw new Error(`Unable to find value '${urlToFind}' in cacheUrls: ` + JSON.stringify(cacheUrls));
      }
    });
  });

  it.skip('should be able to get the unrevisioned cache manager via workbox.precaching', function() {
    const unrevisionedManager = new workbox.precaching.UnrevisionedCacheManager();
    expect(unrevisionedManager).to.exist;

    const cacheName = unrevisionedManager.getCacheName();
    if (!cacheName || typeof cacheName !== 'string' || cacheName.length === 0) {
      throw new Error('Unexpected cache name: ' + cacheName);
    }

    let cacheUrls = unrevisionedManager.getCachedUrls();
    if (!Array.isArray(cacheUrls) || cacheUrls.length !== 0) {
      throw new Error('Unexpected cacheUrls value: ' + JSON.stringify(cacheUrls));
    }

    const URL_1 = '/';
    const URL_2 = '/__echo/date/example.1234.txt';
    unrevisionedManager.addToCacheList({
      unrevisionedFiles: [
        new Request(URL_1),
        URL_2,
      ],
    });

    cacheUrls = unrevisionedManager.getCachedUrls();
    if (!Array.isArray(cacheUrls) || cacheUrls.length !== 2) {
      throw new Error('Unexpected cacheUrls value: ' + JSON.stringify(cacheUrls));
    }

    const urlsToFind = [URL_1, URL_2];
    urlsToFind.forEach((urlToFind) => {
      if (cacheUrls.indexOf(new URL(urlToFind, location).href) === -1) {
        throw new Error(`Unable to find value '${urlToFind}' in cacheUrls: ` + JSON.stringify(cacheUrls));
      }
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe(`Test cacheId Parameter`, function() {
  let cacheManager;

  afterEach(function() {
    if (cacheManager) {
      cacheManager._close();
    }
    cacheManager = null;
  });

  it(`should throw on bad cacheId input`, function() {
    expect(() => {
      cacheManager = new RevisionedCacheManager({
        cacheId: {},
      });
    }).to.throw().with.property('name', 'bad-cache-id');
  });

  it(`should be able to generate cacheManager with cacheId`, function() {
    const CACHE_ID = 'Cache_ID_Example';
    cacheManager = new RevisionedCacheManager({
      cacheId: CACHE_ID,
    });
    cacheManager.getCacheName().indexOf(CACHE_ID).should.not.equal(-1);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe(`Test Cookies with Precache`, function() {
  it(`should cache asset with appropriate cookies with revisions asset`, function() {
    const revManager = new RevisionedCacheManager();
    // const unrevManager = new workbox.precaching.UnrevisionedCacheManager();
    revManager.addToCacheList({
      revisionedFiles: [
        `/__test/cookie/1/`,
      ],
    });
    /* unrevManager.addToCacheList({
      unrevisionedFiles: [
        `/__test/cookie/2/`,
      ],
    });*/

    return Promise.all([
      revManager.install(),
      // unrevManager.install(),
    ])
    .then(() => {
      return Promise.all([
        revManager.cleanup(),
        // unrevManager.cleanup(),
      ]);
    })
    .then(() => {
      return Promise.all([
        caches.match(`/__test/cookie/1/`),
        // caches.match(`/__test/cookie/2/`),
      ]);
    })
    .then((responses) => {
      // The /__test/cookie/ endpoint simply returns a request body
      // of all the cookies as JSON so we should be able to see the
      // swtesting cookie.
      return Promise.all(responses.map((response) => response.json()));
    })
    .then((responses) => {
      responses.forEach((response) => {
        if (!response.swtesting) {
          throw new Error(`The 'swtesting' cookie was not found.`);
        }
      });
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-precaching/test/static/test-data.js');

describe(`Test Failing Cache Behavior`, function() {
  it(`should fail to install revisioned with 404 cache request`, function() {
    const revisionedCacheManager = new RevisionedCacheManager();
    revisionedCacheManager.addToCacheList({
      revisionedFiles: [
        '/__test/404/',
      ],
    });
    return revisionedCacheManager.install().then(() => {
      throw new Error('Expected error to be thrown.');
    }, (err) => {
      expect(err).to.exist;
      expect(err.name).to.equal('request-not-cached');
      expect(err.extras.url).to.equal(new URL('/__test/404/', self.location).toString());
    });
  });

  it.skip(`should fail to install unrevisioned with 404 cache request`, function() {
    const unrevisionedCacheManager = new workbox.precaching.UnrevisionedCacheManager();
    unrevisionedCacheManager.addToCacheList({
      unrevisionedFiles: [
        '/__test/404/',
      ],
    });
    return unrevisionedCacheManager.install().then(() => {
      throw new Error('Expected error to be thrown.');
    }, (err) => {
      expect(err).to.exist;
      expect(err.name).to.equal('request-not-cached');
      expect(err.extras.url).to.equal(new URL('/__test/404/', self.location).toString());
    });
  });

  it(`should fail to cache revisioned opaque responses by default`, function() {
    const revisionedCacheManager = new RevisionedCacheManager();
    revisionedCacheManager.addToCacheList({
      revisionedFiles: workbox.__TEST_DATA['opaque'],
    });
    return revisionedCacheManager.install().then(() => {
      throw new Error('Expected error to be thrown.');
    }, (err) => {
      expect(err).to.exist;
      expect(err.name).to.equal('request-not-cached');
      expect(err.extras.url).to.equal(new URL(workbox.__TEST_DATA['opaque'][0], self.location).toString());
    });
  });

  it.skip(`should fail to cache unrevisioned opaque responses by default`, function() {
    const unrevisionedCacheManager = new workbox.precaching.UnrevisionedCacheManager();
    unrevisionedCacheManager.addToCacheList({
      unrevisionedFiles: workbox.__TEST_DATA['opaque'],
    });
    return unrevisionedCacheManager.install().then(() => {
      throw new Error('Expected error to be thrown.');
    }, (err) => {
      expect(err).to.exist;
      expect(err.name).to.equal('request-not-cached');
      expect(err.extras.url).to.equal(new URL(workbox.__TEST_DATA['opaque'][0], self.location).toString());
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * # workbox-precaching
 *
 * The precaching library intelligently caches and updates files
 * during the install step of your service worker.
 *
 * When given a list of URL's to precache, this module will go through
 * each URL and check if the URL is already cached and, if it is, compare
 * the hash to see if revision hash has changed.
 *
 * If the revision is old or the entry isn't cached, this library will make
 * a request for the asset and cache it, ensuring the the browsers HTTP cache
 * is skipped by using `Request.cache = 'reload'` or adding a cache busting
 * search parameter to the request.
 *
 * @example
 * importScripts('/<Path to Module>/build/workbox-precaching.min.js');
 *
 * const revCacheManager = new workbox.precaching.RevisionedCacheManager();
 * revCacheManager.addToCacheList({
 *   revisionedFiles: [
 *     '/styles/main.1234.css',
 *     {
 *       url: '/',
 *       revision: '1234'
 *     }
 *   ],
 * });
 *
 * self.addEventListener('install', (event) => {
 *   event.waitUntil(
 *     revCacheManager.install()
 *   );
 * });
 *
 * self.addEventListener('activate', (event) => {
 *   event.waitUntil(
 *     revCacheManager.cleanup()
 *   );
 * });
 *
 * @module workbox-precaching
 */
if (!isServiceWorkerGlobalScope()) {
  // We are not running in a service worker, print error message
  throw new WorkboxError('not-in-sw');
}




var namespace = Object.freeze({
	RevisionedCacheManager: RevisionedCacheManager
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

const exportedSymbols = [
  'RevisionedCacheManager',
];

describe(`Test Library Surface`, function() {
  exportedSymbols.forEach((exportedSymbol) => {
    it(`should expose ${exportedSymbol} publicly`, function() {
      expect(namespace[exportedSymbol]).to.exist;
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe(`Test plugins Parameter`, function() {
  it(`should pass the provided plugins configuration along to the RequestWrapper`, function() {
    // Register two dummy fetchDidFail plugins, and one dummy cacheWillUpdate.
    const cacheManager = new RevisionedCacheManager({
      plugins: [{
        fetchDidFail: () => {},
        cacheWillUpdate: () => {},
      }, {
        fetchDidFail: () => {},
      }],
    });

    expect(cacheManager._requestWrapper.plugins.size).to.eql(2);
    expect(cacheManager._requestWrapper.plugins.get('fetchDidFail').length).to.eql(2);
    expect(cacheManager._requestWrapper.plugins.get('cacheWillUpdate').length).to.eql(1);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe(`sw/revisioned-caching()`, function() {
  let cacheManager;

  const VALID_PATH_REL = '/__echo/date/example.txt';
  const VALID_PATH_ABS = `${location.origin}${VALID_PATH_REL}`;
  const VALID_REVISION = '1234';

  beforeEach(function() {
    cacheManager = new RevisionedCacheManager();
  });

  afterEach(function() {
    cacheManager._close();
    cacheManager = null;
  });

  const badRevisionFileInputs = [
    undefined,
    '',
    '/example.js',
    {},
    {url: 'hello'},
    {revision: '0987'},
    true,
    false,
    123,
    new Request(VALID_PATH_ABS),
    new Request(VALID_PATH_REL),
  ];
  badRevisionFileInputs.forEach((badInput) => {
    it(`should handle bad cacheRevisioned({revisionedFiles='${badInput}'}) input`, function() {
      expect(() => {
        cacheManager.addToCacheList({
          revisionedFiles: badInput,
        });
      }).to.throw(`instance of 'Array'`);
    });

    it(`should handle bad cacheRevisioned('${badInput}') input`, function() {
      expect(() => {
        cacheManager.addToCacheList(badInput);
      }).to.throw(`instance of 'Array'`);
    });
  });

  it(`should handle bad cacheRevisioned('[]') input`, function() {
    expect(() => {
      cacheManager.addToCacheList([]);
    }).to.throw(`instance of 'Array'`);
  });

  it(`should handle cacheRevisioned(null / undefined) inputs`, function() {
    expect(() => {
      cacheManager.addToCacheList({revisionedFiles: null});
    }).to.throw(`instance of 'Array'`);

    expect(() => {
      cacheManager.addToCacheList(null);
    }).to.throw('null');
  });

  it(`should handle cacheRevisioned null array inputs`, function() {
    expect(() => {
      cacheManager.addToCacheList({revisionedFiles: [null]});
    }).to.throw().with.property('name', 'unexpected-precache-entry');
  });

  it(`should handle cacheRevisioned undefined array inputs`, function() {
    expect(() => {
      cacheManager.addToCacheList({revisionedFiles: [undefined]});
    }).to.throw().with.property('name', 'unexpected-precache-entry');
  });

  const badPaths = [
    null,
    undefined,
    false,
    true,
    12345,
    {},
    [],
  ];
  badPaths.forEach((badPath) => {
    it(`should throw an errror for bad path value '${JSON.stringify(badPath)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({revisionedFiles: [badPath]});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }
      // TODO: Changed assertion library to support throwing custom errors.
      // caughtError.name.should.equal('invalid-revisioned-entry');
      console.log(caughtError);
    });

    it(`should throw an errror for bad path value with valid revision '${JSON.stringify(badPath)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({revisionedFiles: [{url: badPath, revision: VALID_REVISION}]});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }
      // TODO: Changed assertion library to support throwing custom errors.
      // caughtError.name.should.equal('invalid-revisioned-entry');
      console.log(caughtError);
    });
  });

  const invalidTypeRevisions = [
    null,
    false,
    true,
    12345,
    {},
    [],
  ];
  invalidTypeRevisions.forEach((invalidRevision) => {
    it(`should throw an error for bad revision value '${JSON.stringify(invalidRevision)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({revisionedFiles: [{url: VALID_PATH_REL, revision: invalidRevision}]});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }

      caughtError.message.indexOf(`The 'revision' parameter has the wrong type`).should.not.equal(-1);
    });
  });

  it(`should throw an error for an empty string revision.`, function() {
    let caughtError;
    try {
      cacheManager.addToCacheList({revisionedFiles: [{url: VALID_PATH_REL, revision: ''}]});
    } catch (err) {
      caughtError = err;
    }

    if (!caughtError) {
      throw new Error('Expected file manifest to cause an error.');
    }

    caughtError.name.should.equal('invalid-object-entry');
    caughtError.extras.should.deep.equal({problemParam: 'revision', problemValue: ''});
  });

  const badCacheBusts = [
    null,
    '',
    '1234sgdgh',
    12345,
    {},
    [],
  ];

  badCacheBusts.forEach((badCacheBust) => {
    it(`should be able to handle bad cacheBust value '${JSON.stringify(badCacheBust)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({revisionedFiles: [
          {url: VALID_PATH_REL, revision: VALID_REVISION, cacheBust: badCacheBust},
        ]});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }

      // TODO: Move assertion library over to custom errors.
      // caughtError.name.should.equal('invalid-revisioned-entry');
    });
  });

  const goodManifestInputs = [
    VALID_PATH_REL,
    {url: VALID_PATH_REL, revision: VALID_REVISION},
    {url: VALID_PATH_REL, revision: VALID_REVISION, cacheBust: true},
    {url: VALID_PATH_REL, revision: VALID_REVISION, cacheBust: false},
    VALID_PATH_ABS,
    {url: VALID_PATH_ABS, revision: VALID_REVISION},
    {url: VALID_PATH_ABS},
    {url: VALID_PATH_ABS, revision: VALID_REVISION, cacheBust: true},
    {url: VALID_PATH_ABS, revision: VALID_REVISION, cacheBust: false},
  ];
  goodManifestInputs.forEach((goodInput) => {
    it(`should be able to handle good cache input '${JSON.stringify(goodInput)}'`, function() {
      cacheManager.addToCacheList({revisionedFiles: [goodInput]});
    });
  });

  it(`should throw error when precaching the same path but different revision`, function() {
    const TEST_PATH = '/__echo/date/hello.txt';
    let thrownError = null;
    try {
      cacheManager.addToCacheList({revisionedFiles: [
        {url: TEST_PATH, revision: '1234'},
      ]});
      cacheManager.addToCacheList({revisionedFiles: [
        {url: TEST_PATH, revision: '5678'},
      ]});
    } catch (err) {
      thrownError = err;
    }
    expect(thrownError).to.exist;
    thrownError.name.should.equal('duplicate-entry-diff-revisions');
    thrownError.extras.should.deep.equal({
      firstEntry: {
        url: new URL(TEST_PATH, self.location).toString(),
        revision: '1234',
      },
      secondEntry: {
        url: new URL(TEST_PATH, self.location).toString(),
        revision: '5678',
      },
    });
  });

  it(`should clean up IDB after a URL is removed from the precache list`, async function() {
    const urls = [1, 2, 3].map((i) => new URL(`/__echo/date/${i}`, location).href);

    const firstRevisionedFiles = urls.map((url) => {
      return {url, revision: 'dummy-revision'};
    });
    cacheManager.addToCacheList({revisionedFiles: firstRevisionedFiles});

    const firstCacheDetails = await cacheManager.install();
    let updatedCount = 0;
    let notUpdatedCount = 0;
    firstCacheDetails.forEach((cacheDetails) => {
      if (cacheDetails.wasUpdated) {
        updatedCount++;
      } else {
        notUpdatedCount++;
      }
    });
    expect(updatedCount).to.equal(3);
    expect(notUpdatedCount).to.equal(0);

    await cacheManager.cleanup();

    const firstIdbUrls = await cacheManager._revisionDetailsModel._idbHelper.getAllKeys();
    expect(firstIdbUrls).to.include.members(urls);

    // Create a new RevisionedCacheManager to trigger a new installation.
    const secondCacheManager = new RevisionedCacheManager();

    const removedUrl = urls.pop();
    const secondRevisionedFiles = urls.map((url) => {
      return {url, revision: 'dummy-revision'};
    });
    secondCacheManager.addToCacheList({revisionedFiles: secondRevisionedFiles});

    const secondCacheDetails = await secondCacheManager.install();
    updatedCount = 0;
    notUpdatedCount = 0;
    secondCacheDetails.forEach((cacheDetails) => {
      if (cacheDetails.wasUpdated) {
        updatedCount++;
      } else {
        notUpdatedCount++;
      }
    });
    expect(updatedCount).to.equal(0);
    expect(notUpdatedCount).to.equal(2);

    await secondCacheManager.cleanup();

    const secondIdbUrls = await secondCacheManager._revisionDetailsModel._idbHelper.getAllKeys();
    expect(secondIdbUrls).to.include.members(urls);
    expect(secondIdbUrls).not.to.include.members([removedUrl]);
  });

  it(`should return empty array from install() if no resources to precache`, async function() {
    const cacheDetails = await cacheManager.install();
    (Array.isArray(cacheDetails)).should.equal(true);
    (cacheDetails.length).should.equal(0);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

describe.skip(`sw/unrevisioned-caching.js`, function() {
  let cacheManager;

  const VALID_PATH_REL = '/__echo/date/example.txt';
  const VALID_PATH_ABS = `${location.origin}${VALID_PATH_REL}`;
  const VALID_REVISION = '1234';

  beforeEach(function() {
    cacheManager = new workbox.precaching.UnrevisionedCacheManager();
  });

  afterEach(function() {
    cacheManager = null;
  });

  const badRevisionFileInputs = [
    undefined,
    '',
    '/example.js',
    {},
    {url: 'hello'},
    {revision: '0987'},
    true,
    false,
    123,
    new Request(VALID_PATH_ABS),
    new Request(VALID_PATH_REL),
  ];
  badRevisionFileInputs.forEach((badInput) => {
    it(`should handle bad cacheUnrevisioned({revisionedFiles='${badInput}'}) input`, function() {
      expect(() => {
        cacheManager.addToCacheList({
          unrevisionedFiles: badInput,
        });
      }).to.throw('instance of \'Array\'');
    });

    it(`should handle bad cacheUnrevisioned('${badInput}') input`, function() {
      expect(() => {
        cacheManager.addToCacheList(badInput);
      }).to.throw('instance of \'Array\'');
    });
  });

  it(`should handle bad cacheUnrevisioned('[]') input`, function() {
    expect(() => {
      cacheManager.addToCacheList([]);
    }).to.throw('instance of \'Array\'');
  });

  it(`should handle cacheUnrevisioned(null / undefined) inputs`, function() {
    expect(() => {
      cacheManager.addToCacheList({unrevisionedFiles: null});
    }).to.throw('instance of \'Array\'');

    expect(() => {
      cacheManager.addToCacheList(null);
    }).to.throw('null');
  });

  const badPaths = [
    null,
    undefined,
    false,
    true,
    12345,
    {},
    [],
  ];

  const badRevisions = [
    null,
    undefined,
    false,
    true,
    '',
    12345,
    {},
    [],
  ];

  const badFileManifests = [];
  badPaths.forEach((badPath) => {
    badFileManifests.push([badPath]);
    badFileManifests.push([{url: badPath, revision: VALID_REVISION}]);
  });
  badRevisions.forEach((badRevision) => {
    badFileManifests.push([{url: VALID_PATH_REL, revision: badRevision}]);
  });

  badFileManifests.forEach((badFileManifest) => {
    it(`should throw an errror for bad url / revision value '${JSON.stringify(badFileManifest)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({unrevisionedFiles: badFileManifest});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }
      if (caughtError.name !== 'invalid-unrevisioned-entry') {
        console.log('Unexpected error: ', caughtError);
      }
      caughtError.name.should.equal('invalid-unrevisioned-entry');
    });
  });

  const badCacheBusts = [
    null,
    '',
    '1234sgdgh',
    12345,
    {},
    [],
  ];

  badCacheBusts.forEach((badCacheBust) => {
    it(`should be able to handle bad cacheBust value '${JSON.stringify(badCacheBust)}'`, function() {
      let caughtError;
      try {
        cacheManager.addToCacheList({unrevisionedFiles: [
          {url: VALID_PATH_REL, revision: VALID_REVISION, cacheBust: badCacheBust},
        ]});
      } catch (err) {
        caughtError = err;
      }

      if (!caughtError) {
        throw new Error('Expected file manifest to cause an error.');
      }

      caughtError.name.should.equal('invalid-unrevisioned-entry');
    });
  });

  const goodManifestInputs = [
    VALID_PATH_REL,
    VALID_PATH_ABS,
    new Request(VALID_PATH_REL),
    new Request(VALID_PATH_ABS),
  ];
  goodManifestInputs.forEach((goodInput) => {
    it(`should be able to handle good cache input '${JSON.stringify(goodInput)}'`, function() {
      cacheManager.addToCacheList({unrevisionedFiles: [goodInput]});
    });
  });
});
//# sourceMappingURL=sw-bundle.js.map
